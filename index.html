<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Black & White Hole Space Game + Supernova + Online</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#000; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display:block; }
    #gui { position:fixed; top:10px; left:10px; background:rgba(0,0,0,.6); color:#fff; padding:10px 12px; border-radius:10px; font-size:14px; pointer-events:none; z-index:10; }
    #gui .row { display:flex; gap:8px; align-items:center; }
    #gui .row + .row { margin-top:6px; }

    /* Online panel */
    #onlinePanel { position:fixed; top:10px; right:10px; width:min(360px, 42vw); max-height:80vh; display:flex; flex-direction:column; gap:8px; padding:12px; border-radius:12px; background:rgba(10,14,24,.75); color:#eaf0ff; box-shadow:0 10px 30px rgba(0,0,0,.35); z-index:20; }
    #onlinePanel h3 { margin:0; font-size:16px; display:flex; align-items:center; gap:8px; }
    #onlinePanel .grid { display:grid; grid-template-columns: 1fr auto; gap:8px; }
    #onlinePanel input, #onlinePanel button, #onlinePanel textarea { font:inherit; border-radius:10px; border:1px solid rgba(255,255,255,.12); padding:8px 10px; background:rgba(255,255,255,.06); color:#fff; }
    #onlinePanel button { cursor:pointer; transition:transform .04s ease; }
    #onlinePanel button:active { transform:scale(.98); }
    #onlinePanel small { color:#9eb1ff; }
    #chatLog { border-radius:10px; padding:8px; background:rgba(255,255,255,.04); overflow:auto; max-height:32vh; font-size:13px; line-height:1.35; }
    #chatLog .msg { margin:6px 0; }
    #chatLog .sys { opacity:.8; font-style:italic; }
    #leaderboard { border-radius:10px; padding:8px; background:rgba(255,255,255,.04); overflow:auto; max-height:22vh; }
    #leaderboard .row { display:flex; justify-content:space-between; padding:4px 2px; border-bottom:1px dashed rgba(255,255,255,.08); }
    #leaderboard .row:last-child { border-bottom:none; }
    #onlineFooter { display:flex; gap:8px; }
    #onlineFooter input { flex:1; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.08); font-size:12px; }

    /* Tooltip for controls (mobile) */
    #hint { position:fixed; bottom:10px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.55); color:#fff; padding:8px 12px; border-radius:999px; font-size:12px; z-index:15; }
  </style>
</head>
<body>
  <canvas id="space"></canvas>

  <div id="gui">
    <div class="row">üï≥Ô∏è <span>Left Click: Black Hole</span></div>
    <div class="row">‚ö™ <span>Right Click: White Hole</span></div>
    <div class="row">üí´ Stars: <span id="starCount">0</span></div>
    <div class="row">‚ö° Energy: <span id="energyCount">0</span></div>
    <div class="row">üéØ Score: <span id="scoreCount">0</span></div>
  </div>

  <div id="onlinePanel">
    <h3>üåê Online <span id="onlineStatus" class="pill">offline</span></h3>
    <div class="grid">
      <input id="playerName" placeholder="Your name" maxlength="20" />
      <button id="connectBtn">Connect</button>
    </div>
    <small>If you haven't added your Firebase config yet, the panel will stay offline and the game still works locally.</small>

    <div>
      <strong>üë• Online: <span id="onlineCount">0</span></strong>
    </div>

    <div>
      <strong>üèÜ Leaderboard (Top 15)</strong>
      <div id="leaderboard"></div>
    </div>

    <div>
      <strong>üí¨ Global Chat</strong>
      <div id="chatLog"></div>
      <div id="onlineFooter">
        <input id="chatInput" placeholder="Type a message and press Enter" />
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>

  <div id="hint">Tip: drag holes with the mouse ‚Ä¢ Supernova stars glow yellow/orange and explode!</div>

  <!-- Sounds -->
  <audio id="boomSound" src="https://cdn.pixabay.com/audio/2022/03/10/audio_246f7279a2.mp3"></audio>
  <audio id="supernovaSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_2f2929180f.mp3?filename=explosion-6071.mp3"></audio>

  <script>
    // ---------- Canvas + Core State ----------
    const canvas = document.getElementById('space');
    const ctx = canvas.getContext('2d');
    function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
    addEventListener('resize', resize); resize();

    const stars = [];
    const blackHoles = [];
    const whiteHoles = [];
    const absorbedStars = [];
    const mergePairs = [];
    const supernovas = [];
    const fragments = []; // star fragments from supernova

    const guiStarCount = document.getElementById('starCount');
    const guiEnergyCount = document.getElementById('energyCount');
    const guiScoreCount = document.getElementById('scoreCount');
    const boomSound = document.getElementById('boomSound');
    const supernovaSound = document.getElementById('supernovaSound');

    let score = 0;
    let energy = 0;

    // ---------- Utility ----------
    const RAND = (a,b)=> a + Math.random()*(b-a);
    const DIST = (x1,y1,x2,y2)=> Math.hypot(x1-x2,y1-y2);

    // ---------- Particles (Fragments) ----------
    class Fragment {
      constructor(x,y){
        this.x=x; this.y=y;
        const sp = RAND(2, 6);
        const ang = RAND(0, Math.PI*2);
        this.vx = Math.cos(ang)*sp;
        this.vy = Math.sin(ang)*sp;
        this.life = RAND(30, 90);
        this.size = RAND(0.8, 2.4);
        this.alpha = 1;
        this.twinkle = Math.random() < .3;
      }
      update(){
        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.985; this.vy *= 0.985; // slight drag
        this.life--;
        this.alpha = Math.max(0, this.life/90);
        if(this.life<=0) this.dead = true;
      }
      draw(){
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fillStyle = this.twinkle ? '#ffe8a8' : '#ffd27d';
        ctx.shadowBlur = 10; ctx.shadowColor = '#ffd27d';
        ctx.fill();
        ctx.restore();
      }
    }

    // ---------- Stars ----------
    class Star {
      constructor(x, y, radius) {
        this.x = x ?? Math.random() * canvas.width;
        this.y = y ?? Math.random() * canvas.height;
        this.radius = radius ?? Math.random() * 3 + 1.5;
        this.baseColor = 'white';
        this.color = this.baseColor;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.isSupernovaCandidate = Math.random() < 0.02; // 2%
        this.life = this.isSupernovaCandidate ? 600 + Math.random() * 600 : Infinity;
      }
      update() {
        // gravity to black holes
        for (let bh of blackHoles) {
          const dx = bh.x - this.x; const dy = bh.y - this.y; const dist = Math.hypot(dx,dy);
          if (dist < 300) {
            const force = ((300 - dist) / 10000) * this.radius * (bh.radius / 10);
            this.vx += dx * force; this.vy += dy * force;
          }
          if (dist < bh.radius) {
            if (this.isSupernovaCandidate) triggerSupernova(this.x, this.y, true);
            absorbedStars.push(this);
            this.dead = true;
            score++; energy += 5; queueScoreSync();
          }
        }
        this.x += this.vx; this.y += this.vy;
        // lifetime for candidate
        if (this.isSupernovaCandidate) {
          this.life--;
          if (this.life <= 0) { triggerSupernova(this.x, this.y, false); this.dead = true; }
          this.color = this.life < 200 ? 'orange' : 'yellow';
        } else this.color = this.baseColor;
      }
      draw() {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color; ctx.fill();
      }
    }

    // ---------- Supernova ----------
    class Supernova {
      constructor(x, y) {
        this.x = x; this.y = y; this.radius = 12; this.maxRadius = 260; this.alpha = 1;
      }
      update() {
        this.radius += 9; this.alpha -= 0.016; if (this.alpha <= 0) this.dead = true;
        // Blast wave pushes stars
        for (let s of stars) {
          const d = DIST(s.x, s.y, this.x, this.y);
          if (d < this.radius) {
            const angle = Math.atan2(s.y - this.y, s.x - this.x);
            const power = (this.maxRadius - d) / 48;
            s.vx += Math.cos(angle) * power; s.vy += Math.sin(angle) * power;
          }
        }
      }
      draw() {
        const g = ctx.createRadialGradient(this.x, this.y, this.radius*0.2, this.x, this.y, this.radius);
        g.addColorStop(0, `rgba(255,240,160,${Math.max(0,this.alpha)})`);
        g.addColorStop(1, `rgba(255,120,40,${Math.max(0,this.alpha*0.6)})`);
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
      }
    }

    function triggerSupernova(x, y, absorbedByBH){
      supernovas.push(new Supernova(x, y));
      for(let i=0;i<40;i++) fragments.push(new Fragment(x, y));
      try { supernovaSound.currentTime = 0; supernovaSound.play(); } catch(e){}
      score += absorbedByBH ? 14 : 10; energy += 20; queueScoreSync();
      postSystemMessage(`Supernova at (${Math.round(x)},${Math.round(y)}) ‚ú®`);
    }

    // ---------- Holes ----------
    class BlackHole {
      constructor(x, y, isGiant = false) { this.x = x; this.y = y; this.radius = isGiant ? 30 : 10; this.lifetime = 60*20; }
      update(){ this.lifetime--; }
      isExpired(){ return this.lifetime <= 0; }
      draw(){
        const grad = ctx.createRadialGradient(this.x, this.y, this.radius*.3, this.x, this.y, this.radius);
        grad.addColorStop(0,'magenta'); grad.addColorStop(1,'purple');
        ctx.beginPath(); ctx.fillStyle = grad; ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
      }
    }
    class WhiteHole {
      constructor(x, y, isGiant = false) { this.x = x; this.y = y; this.radius = isGiant ? 30 : 10; this.cooldown = 0; this.lifetime = 60*20; }
      release(){
        if (absorbedStars.length > 0 && this.cooldown <= 0) {
          const released = absorbedStars.shift();
          const angle = Math.random() * Math.PI * 2; const speed = this.radius === 30 ? 4 : 2;
          const newStar = new Star(this.x, this.y, released.radius);
          newStar.vx = Math.cos(angle) * speed; newStar.vy = Math.sin(angle) * speed;
          stars.push(newStar); this.cooldown = 30;
        } else { this.cooldown--; }
        this.lifetime--;
      }
      isExpired(){ return this.lifetime <= 0; }
      draw(){
        const grad = ctx.createRadialGradient(this.x, this.y, this.radius*.3, this.x, this.y, this.radius);
        grad.addColorStop(0,'lightcyan'); grad.addColorStop(1,'cyan');
        ctx.beginPath(); ctx.fillStyle = grad; ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
      }
    }

    function isGiantChance(){ return Math.random() < 0.125; }

    function initStars(num = 300){ for(let i=0;i<num;i++) stars.push(new Star()); }
    function spawnStarsOverTime(){ setInterval(()=>{ for(let i=0;i<3;i++) stars.push(new Star()); }, 150); }
    function updateGUI(){ guiStarCount.textContent = stars.length; guiEnergyCount.textContent = energy; guiScoreCount.textContent = score; }

    // ---------- Dragging Holes ----------
    let draggingHole = null, dragOffsetX = 0, dragOffsetY = 0;
    canvas.addEventListener('mousedown', (e)=>{
      const mx=e.clientX, my=e.clientY;
      for (let hole of [...blackHoles, ...whiteHoles]){
        const dx = hole.x - mx, dy = hole.y - my; if (Math.hypot(dx,dy) < hole.radius + 10){ draggingHole = hole; dragOffsetX = dx; dragOffsetY = dy; break; }
      }
    });
    ['mouseup','mouseleave'].forEach(ev=> canvas.addEventListener(ev, ()=> draggingHole = null));
    canvas.addEventListener('mousemove', (e)=>{ if(draggingHole){ draggingHole.x = e.clientX + dragOffsetX; draggingHole.y = e.clientY + dragOffsetY; }});
    canvas.addEventListener('click', (e)=>{ if(draggingHole) return; const giant = isGiantChance(); blackHoles.push(new BlackHole(e.clientX, e.clientY, giant)); });
    canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(draggingHole) return; const giant = isGiantChance(); whiteHoles.push(new WhiteHole(e.clientX, e.clientY, giant)); });

    // ---------- Main Loop ----------
    function animate(){
      ctx.fillStyle = 'rgba(0,0,0,.24)'; ctx.fillRect(0,0,canvas.width, canvas.height);

      // stars
      for(let i=stars.length-1;i>=0;i--){ const s = stars[i]; s.update(); s.draw(); if(s.dead) stars.splice(i,1); }

      // fragments
      for(let i=fragments.length-1;i>=0;i--){ const f = fragments[i]; f.update(); f.draw(); if(f.dead) fragments.splice(i,1); }

      // holes
      for(let i=blackHoles.length-1;i>=0;i--){ const bh=blackHoles[i]; bh.update(); bh.draw(); if(bh.isExpired()) blackHoles.splice(i,1); }
      for(let i=whiteHoles.length-1;i>=0;i--){ const wh=whiteHoles[i]; wh.release(); wh.draw(); if(wh.isExpired()) whiteHoles.splice(i,1); }

      // supernovas
      for(let i=supernovas.length-1;i>=0;i--){ const sn = supernovas[i]; sn.update(); sn.draw(); if(sn.dead) supernovas.splice(i,1); }

      // hole interactions
      for (let bh of blackHoles){
        for (let wh of whiteHoles){
          const dx = bh.x - wh.x, dy = bh.y - wh.y; const dist = Math.hypot(dx,dy);
          if (dist < 150){ const force = (150 - dist) / 8000; const fx = dx*force, fy = dy*force; bh.x -= fx; bh.y -= fy; wh.x += fx; wh.y += fy; }
          if (dist < bh.radius + wh.radius){ ctx.strokeStyle='red'; ctx.beginPath(); ctx.moveTo(bh.x,bh.y); ctx.lineTo(wh.x,wh.y); ctx.stroke(); bh.x += Math.random()*4 - 2; bh.y += Math.random()*4 - 2; wh.x += Math.random()*4 - 2; wh.y += Math.random()*4 - 2; }
        }
      }

      // merge pairs timing
      for (let i=mergePairs.length-1;i>=0;i--){
        const pair = mergePairs[i], {bh, wh} = pair; const d = DIST(bh.x,bh.y,wh.x,wh.y);
        if (d < bh.radius + wh.radius){
          pair.timer++;
          if (pair.timer >= 300){
            try{ boomSound.currentTime=0; boomSound.play(); }catch(e){}
            for (let s of stars){ const d2 = DIST(s.x,s.y,bh.x,bh.y); if(d2<200){ const ang = Math.atan2(s.y-bh.y, s.x-bh.x); const power=(200-d2)/5; s.vx += Math.cos(ang)*power; s.vy += Math.sin(ang)*power; }}
            ctx.fillStyle='rgba(255,200,50,.5)'; ctx.beginPath(); ctx.arc(bh.x,bh.y,120,0,Math.PI*2); ctx.fill();
            blackHoles.splice(blackHoles.indexOf(bh),1); whiteHoles.splice(whiteHoles.indexOf(wh),1); mergePairs.splice(i,1); continue;
          }
        } else mergePairs.splice(i,1);
      }

      // register pairs
      for (let i=blackHoles.length-1;i>=0;i--){ const bh = blackHoles[i]; for(let j=whiteHoles.length-1;j>=0;j--){ const wh = whiteHoles[j]; const d = DIST(bh.x,bh.y,wh.x,wh.y); if(d<bh.radius+wh.radius){ if(!mergePairs.find(p=>p.bh===bh && p.wh===wh)) mergePairs.push({bh,wh,timer:0}); }}}

      updateGUI(); requestAnimationFrame(animate);
    }

    initStars(); spawnStarsOverTime(); animate();

    // ---------- ONLINE SYSTEM (Firebase RTDB) ----------
    // This works if you provide your Firebase web app config below. If left empty, the panel stays offline gracefully.
    const online = {
      enabled:false, app:null, db:null, refs:{}, uid:null, name:null, presenceKey:null, scoreDebounce:null
    };

    // Replace with your Firebase config
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyCEYmx8zQ9UR7f3IPq3C8G57kAVMjRKltg",
      authDomain: "nira-hold.firebaseapp.com",
      projectId: "nira-hold",
      storageBucket: "nira-hold.firebasestorage.app",
      messagingSenderId: "355299245486",
      appId: "1:355299245486:web:1e0352bb8d8123d6825c3f",
      measurementId: "G-67BJK5CN2F"
    };

    const onlineStatusEl = document.getElementById('onlineStatus');
    const playerNameEl = document.getElementById('playerName');
    const connectBtn = document.getElementById('connectBtn');
    const onlineCountEl = document.getElementById('onlineCount');
    const chatLogEl = document.getElementById('chatLog');
    const chatInputEl = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const leaderboardEl = document.getElementById('leaderboard');

    function setStatus(txt, ok){ onlineStatusEl.textContent = txt; onlineStatusEl.style.background = ok? 'rgba(46, 204, 113,.2)' : 'rgba(255,255,255,.08)'; }

    function appendChat(author, text, sys=false){
      const div = document.createElement('div');
      div.className = 'msg' + (sys? ' sys' : '');
      div.textContent = sys? text : `${author}: ${text}`;
      chatLogEl.appendChild(div); chatLogEl.scrollTop = chatLogEl.scrollHeight;
    }
    function postSystemMessage(text){ appendChat('system', text, true); try{ if(online.enabled){ const {push, ref} = online.dbFns; push(ref(online.db, 'chat'), {a:'sys', t:text, ts:Date.now()}); } }catch(e){} }

    async function connect(){
      const name = (playerNameEl.value || 'Guest').trim().slice(0,20) || 'Guest';
      try{
        if(!FIREBASE_CONFIG.apiKey){ setStatus('offline', false); appendChat('system', 'No Firebase config provided. Staying offline.', true); return; }

        // Import Firebase modules dynamically (modern browsers)
        const [{ initializeApp }, { getDatabase, ref, push, set, onValue, onDisconnect, serverTimestamp, query, orderByChild, limitToLast }, { getAuth, signInAnonymously, onAuthStateChanged }] = await Promise.all([
          import('https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js'),
          import('https://www.gstatic.com/firebasejs/10.13.0/firebase-database.js'),
          import('https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js')
        ]);

        online.dbFns = { ref, push, set, onValue, onDisconnect, serverTimestamp, query, orderByChild, limitToLast };
        online.app = initializeApp(FIREBASE_CONFIG);
        online.db = getDatabase(online.app);
        const auth = getAuth(online.app);
        await signInAnonymously(auth);

        onAuthStateChanged(auth, (user)=>{ if(user){ online.uid = user.uid; online.name = name; setupPresence(); subscribeChat(); subscribeLeaderboard(); setStatus('online', true); appendChat('system', `Connected as ${name}`, true); online.enabled = true; queueScoreSync(); } });
      }catch(err){ console.error(err); setStatus('error', false); appendChat('system', 'Online connection failed. Check console.', true); }
    }

    function setupPresence(){
      const { ref, set, onDisconnect, serverTimestamp, onValue } = online.dbFns;
      const presRef = ref(online.db, `presence/${online.uid}`);
      online.presenceKey = `presence/${online.uid}`;
      set(presRef, { name: online.name, since: serverTimestamp(), score });
      onDisconnect(presRef).remove?.();
      // Online count
      onValue(ref(online.db, 'presence'), (snap)=>{ const val = snap.val() || {}; onlineCountEl.textContent = Object.keys(val).length; });
    }

    function subscribeChat(){
      const { ref, onValue, limitToLast, query } = online.dbFns;
      const q = query(ref(online.db, 'chat'), limitToLast(50));
      onValue(q, (snap)=>{
        const val = snap.val() || {}; chatLogEl.innerHTML='';
        Object.values(val).sort((a,b)=>a.ts-b.ts).forEach(m=>{ appendChat(m.a==='sys'?'system':m.a, m.t, m.a==='sys'); });
      });
    }

    function sendChat(){
      if(!online.enabled) return appendChat('system','You are offline.');
      const text = chatInputEl.value.trim(); if(!text) return;
      chatInputEl.value = '';
      const { ref, push, serverTimestamp } = online.dbFns;
      push(ref(online.db,'chat'), { a: online.name, t: text, ts: serverTimestamp() });
    }

    function subscribeLeaderboard(){
      const { ref, onValue, orderByChild, limitToLast, query } = online.dbFns;
      const q = query(ref(online.db, 'leaderboard'), orderByChild('score'), limitToLast(15));
      onValue(q, (snap)=>{
        const val = snap.val() || {}; const list = Object.values(val).sort((a,b)=> b.score - a.score);
        leaderboardEl.innerHTML = list.map((e,i)=> `<div class="row"><span>${i+1}. ${e.name||'Guest'}</span><span>${e.score}</span></div>`).join('');
      });
    }

    function queueScoreSync(){
      if(!online.enabled) return; // no-op offline
      clearTimeout(online.scoreDebounce);
      online.scoreDebounce = setTimeout(()=>{
        const { ref, set } = online.dbFns;
        if(!online.uid) return;
        set(ref(online.db, `leaderboard/${online.uid}`), { name: online.name || 'Guest', score, ts: Date.now() });
        if(online.presenceKey) set(ref(online.db, online.presenceKey), { name: online.name, since: Date.now(), score });
      }, 500);
    }

    connectBtn.addEventListener('click', connect);
    sendBtn.addEventListener('click', sendChat);
    chatInputEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter') sendChat(); });
  </script>
</body>
</html>
